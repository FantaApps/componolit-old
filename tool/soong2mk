#!/usr/bin/env python3

# TODO
#
# - Fix variable use (lists)
# - Concatenation

import sys
import argparse
import unittest

from pyparsing import *

class Wrap:

    def __init__ (self, data):
        self.__data = data

    def unwrap (self):
        return self.__data

class Soong:

    def __init__ (self, basedir = '.'):
        self._data    = {'variables': {}, 'sections': []}
        self._basedir = basedir

        name  = Word (alphanums + "_")
        comma = Literal (',')

        # Variable reference
        varref = Word (alphanums + "_")
        varref.setParseAction (self.varrefAction)

        # String
        string = QuotedString ('"', escChar='\\').setParseAction (lambda s, l, t: t[0])

        # List of strings
        stringlist = Literal ("[") + Optional (delimitedList (string)) + Optional (comma) + Literal ("]")
        stringlist.setParseAction (self.stringlistAction)

        # Element
        wrapped_data = delimitedList (stringlist|string|varref, delim='+')
        wrapped_data.setParseAction (self.dataAction)

        # Element inside a section
        dictelem = name + Suppress (Literal (':')) + wrapped_data
        dictelem.setParseAction (self.dictelemAction)

        # Section (unnamed)
        section = Literal ("{") + delimitedList (dictelem) + Optional (comma) + Literal ("}")
        section.setParseAction (self.sectionAction)

        # Named section
        namedsection = name + section
        namedsection.setParseAction (self.namedsectionAction)

        # Variable
        variable = name + Suppress (Literal ("=")) + wrapped_data
        variable.setParseAction (self.variableAction)

        # Extension
        extension = name + Suppress (Literal ("+=")) + wrapped_data
        extension.setParseAction (self.extensionAction)

        # Soong file
        self._grammar = ZeroOrMore (namedsection | Suppress (variable) | Suppress (extension)) + StringEnd()
        self._grammar.setParseAction (self.soongAction)

        # C and C++ style comments
        self._grammar.ignore (cppStyleComment | cStyleComment)

    def variableAction (self, string, location, tokens):
        self.variables()[tokens[0]] = tokens[1].unwrap()

    def varrefAction (self, string, location, tokens):
        return self.variables()[tokens[0]]

    def extensionAction (self, string, location, tokens):
        varname   = tokens[0]
        variables = self.variables()
        value     = variables[varname]
        variables[varname] = value + tokens[1].unwrap()

    def stringlistAction (self, string, location, tokens):
        last = -2 if tokens[-2] == ',' else -1
        return [tokens[1:last]]

    def dataAction (self, string, location, tokens):
        result = tokens[0]
        for token in tokens[1:]:
            if type (token) is list:
                result.extend (token)
            else:
                result += token
        return Wrap (result)

    def dictelemAction (self, string, location, tokens):
        return (tokens[0], tokens[1].unwrap())

    def sectionAction (self, string, location, tokens):
        result = {}
        last = -2 if tokens[-2] == ',' else -1
        for token in tokens[1:last]:
            result[token[0]] = token[1]
        return result

    def namedsectionAction (self, string, location, tokens):
        return (tokens[0], tokens[1])

    def soongAction (self, string, location, tokens):
        self._data['sections'].extend (tokens)

    def parse (self, infile):
        with open (infile, 'r') as f:
            self._grammar.parseFile (f)

    def data (self):
        return self._data['sections']

    def variables (self):
        return self._data['variables']

class TestSoong (unittest.TestCase):

    def setUp (self):
        self.testdir = "tests/soong2mk"

    def parse (self, filename):
        infile = self.testdir + "/" + filename + ".bp"
        soong = Soong()
        soong.parse (infile)
        return soong

    def test_empty_input (self):
        """
        Parsing an empty file must yield an empty list.
        """
        self.assertFalse (self.parse ("001_empty_file").data())

    def test_cpp_comment_only (self):
        """
        Parsing a file with only a C++ style comment must yield an empty list.
        """
        soong = self.parse ("002_cpp_comment_only")
        self.assertFalse (soong.data())

    def test_c_comment_only (self):
        """
        Parsing a file with only a C style comment must yield an empty list.
        """
        soong = self.parse ("003_c_comment_only")
        self.assertFalse (soong.data())

    def test_mixed_comment_only (self):
        """
        Parsing a file with only C and C++ style comments must yield an empty list.
        """
        soong = self.parse ("004_mixed_comment_only")
        self.assertFalse (soong.data())

    def test_single_empty_section (self):
        """
        An empty section must raise an exception
        """
        try:
            self.parse ("005_single_empty_section")
        except Exception:
            return
        self.fail("Empty section not detected")

    def test_single_simple_section (self):
        """
        An single section mapping a name to a scalar string value must result in
        a dict mapping that section name to dict. This dict must contain only that
        element name which is mapped to the correct string value.
        """
        soong = self.parse ("006_single_simple_section")
        self.assertEqual (soong.data(), [('section2', {'foo': 'bar'})])

    def test_trailing_comma (self):
        """
        A section with multiple elements where the last element has a trailing
        comma (without a further element) must be parsed correctly.
        """
        soong = self.parse ("007_trailing_comma")
        self.assertEqual (soong.data(), [('section3', {'element1': 'data1', 'element2': 'data2'})])

    def test_multiple_simple_sections (self):
        """
        Two sections with simple data.
        """
        soong = self.parse ("008_multiple_simple_sections")
        self.assertEqual (soong.data(), [('section5', {'element1': 'data1', 'element2': 'data2'}),
                                         ('section6', {'element3': 'data3', 'element4': 'data4'})])

    def test_section_with_lists (self):
        """
        A section containing lists of strings
        """
        soong = self.parse ("009_section_with_lists")
        self.assertEqual (soong.data(), [('section8', {'element8':  ['data1', 'data2', 'data3'],
                                                       'element9':  ['data4', 'data5'],
                                                       'element10': ['data6']})])

    def test_single_variable (self):
        """
        File with one single variable assignment. Variables are stored in the 'variables' element
        of self._data
        """
        soong = self.parse ("010_single_variable")
        self.assertEqual (soong.variables(), {'some_variable': 'data10'})

    def test_single_variable_list (self):
        """
        File with one single variable assignment of a string list.
        """
        soong = self.parse ("011_single_variable_list")
        self.assertEqual (soong.variables(), {'variable_2': ['data1', 'data2']})

    def test_variable_use (self):
        """
        Use variable in a section. Eventually, the section must contain the variable value.
        """
        soong = self.parse ("012_variable_use")
        self.assertEqual (soong.data(), [('section_10', {'data5': ['data3', 'data4']})])

    def test_missing_variable (self):
        """
        Use non-existing variable in a section. Must raise an exception.
        """

        try:
            self.parse ("013_missing_variable")
        except Exception:
            return
        self.fail("Missing variable not detected")

    def test_string_concatenation (self):
        """
        Concatenate string from two constants
        """
        soong = self.parse ("014_string_const_cat")
        self.assertEqual (soong.data(), [('section_11', {'data6': 'leftright'})])

    def test_string_var_concatenation (self):
        """
        Concatenate string from a constant and a variable.
        """
        soong = self.parse ("015_string_var_cat")
        self.assertEqual (soong.data(), [('section_12', {'data7': 'leftVARIABLE1', 'data8': 'VARIABLE2right'})])

    def test_var_stringlist_extension (self):
        """
        Assign a string list to a variable and extend it by another list.
        """
        soong = self.parse ("016_var_stringlist_ext")
        self.assertEqual (soong.variables(), {'variable_12': ['data15', 'data16']})

    def test_var_string_extension (self):
        """
        Concatenate two strings
        """
        soong = self.parse ("017_var_string_ext")
        self.assertEqual (soong.variables(), {'variable_19': 'data20data21'})

    def test_stringlist_cat (self):
        """
        Concatenate two string lists
        """
        soong = self.parse ("018_stringlist_const_cat")
        self.assertEqual (soong.data(), [('section_21', {'data7': ['data30', 'data32', 'data33', 'data34', 'data35']})])

    # Next: List concatenation

if __name__ == "__main__":

    if len (sys.argv) == 2 and sys.argv[1] == 'test':
        suite = unittest.TestLoader().loadTestsFromTestCase(TestSoong)
        unittest.TextTestRunner().run(suite)
        sys.exit (0)

    parser = argparse.ArgumentParser (description = 'Translate soong files to make statements')
    parser.add_argument ('--verbose', help='Verbose output', action='store_true')
    parser.add_argument ('--basedir', help='Base directory', action='store', required=True)
    parser.add_argument ('--output',  help='Write result to file', action='store', required=True)
    parser.add_argument ('--prefix',  help='Prepend prefix to variables', action='store', default='')
    parser.add_argument ('--include', help='Directory to load Android.bp from', action='append', required=True)
    parser.add_argument ('queries',   help='Query data from soong file', nargs='+')
    args = parser.parse_args()

    soong = Soong (args.basedir)
    for bp in args.include:
        soong.parse (bp)

    with open (args.output, 'w') as f:
        for q in args.queries:
            query = SoongQuery (q)
            f.write (repr(soong[query]))

