#!/usr/bin/env python3

# TODO
#

import os
import sys
import argparse
import unittest

from pyparsing import *

class MissingVariable (Exception): pass
class DuplicateVariable (Exception): pass
class IncompatibleConcatenation (Exception): pass

class Wrap:

    def __init__ (self, data):
        self.__data = data

    def unwrap (self):
        return self.__data

#
# Soong parser
#
class Soong:

    def __init__ (self, basedir = '.'):
        self._data    = {'variables': {}, 'sections': []}
        self._basedir = basedir

        name  = Word (alphanums + "_")
        comma = Literal (',')
        true  = Literal ('true').setParseAction (lambda v : Wrap (True))
        false = Literal ('false').setParseAction (lambda v : Wrap (False))

        # Variable reference
        varref = Word (alphanums + "_")
        varref.setParseAction (self.varrefAction)

        # Boolean literal true/false
        boolean = true | false

        # String
        string = QuotedString ('"', escChar='\\').setParseAction (lambda s, l, t: t[0])

        # List of strings
        stringlist = Literal ("[") + Optional (delimitedList (string)) + Optional (comma) + Literal ("]")
        stringlist.setParseAction (self.stringlistAction)

        # Element
        wrapped_data = delimitedList (stringlist|string|varref, delim='+')
        wrapped_data.setParseAction (self.dataAction)

        # Data
        data = boolean | wrapped_data
        data.setParseAction (lambda s, l, t: t)

        # Element inside a section
        section = Forward()
        dictelem = name + Suppress (Literal (':')|Literal ('=')) + (data|section)
        dictelem.setParseAction (self.dictelemAction)

        # Section (unnamed)
        section << Literal ("{") + Optional (delimitedList (dictelem)) + Optional (comma) + Literal ("}")
        section.setParseAction (self.sectionAction)

        # Named section
        namedsection = name + section
        namedsection.setParseAction (self.namedsectionAction)

        # Variable
        variable = name + Suppress (Literal ("=")) + data
        variable.setParseAction (self.variableAction)

        # Extension
        extension = name + Suppress (Literal ("+=")) + data
        extension.setParseAction (self.extensionAction)

        # Soong file
        self._grammar = ZeroOrMore (namedsection | Suppress (variable) | Suppress (extension)) + StringEnd()
        self._grammar.setParseAction (self.soongAction)

        # C and C++ style comments
        self._grammar.ignore (cppStyleComment | cStyleComment)

    def variableAction (self, string, location, tokens):
        varname = tokens[0]
        if varname in self.variables():
            raise DuplicateVariable
        data = tokens[1].unwrap()
        self.variables()[varname] = data

    def varrefAction (self, string, location, tokens):
        varname = tokens[0]
        if not varname in self.variables():
            raise MissingVariable ("Variable '" + varname + "' not found [line " + str(location) + "]")
        return [self.variables()[varname]]

    def extensionAction (self, string, location, tokens):
        varname   = tokens[0]
        variables = self.variables()
        value     = variables[varname]
        variables[varname] = value + tokens[1].unwrap()

    def stringlistAction (self, string, location, tokens):
        last = -2 if tokens[-2] == ',' else -1
        return [tokens[1:last]]

    def dataAction (self, string, location, tokens):
        result = tokens[0]
        for token in tokens[1:]:
            if type (token) != type (tokens[0]):
                raise IncompatibleConcatenation
            if type (token) is list:
                result.extend (token)
            else:
                result += token
        return Wrap (result)

    def dictelemAction (self, string, location, tokens):
        return (tokens[0], tokens[1].unwrap())

    def sectionAction (self, string, location, tokens):
        result = {}
        last = -2 if tokens[-2] == ',' else -1
        for token in tokens[1:last]:
            result[token[0]] = token[1]
        return Wrap (result)

    def namedsectionAction (self, string, location, tokens):
        return (tokens[0], tokens[1].unwrap())

    def soongAction (self, string, location, tokens):
        self._data['sections'].extend (tokens)

    def parse (self, infile):
        with open (infile, 'r') as f:
            self._grammar.parseFile (f)

    def data (self):
        return self._data['sections']

    def variables (self):
        return self._data['variables']

#
# Soong parsers test cases
#
class TestSoong (unittest.TestCase):

    def setUp (self):
        self.testdir = "tests/soong2mk"

    def fullpath (self, testfile):
        return self.testdir + "/" + testfile + ".bp"

    def parse (self, filename):
        soong = Soong()
        soong.parse (self.fullpath (filename))
        return soong

    def assert_data (self, filename, data):
        soong = self.parse (filename)
        self.assertEqual (soong.data(), data, self.fullpath (filename))

    def assert_variables (self, filename, variables):
        soong = self.parse (filename)
        self.assertEqual (soong.variables(), variables, self.fullpath (filename))

    def test_empty_input (self):
        """
        Parsing an empty file must yield an empty list.
        """
        self.assert_data ("001_empty_file", [])

    def test_cpp_comment_only (self):
        """
        Parsing a file with only a C++ style comment must yield an empty list.
        """
        self.assert_data ("002_cpp_comment_only", [])

    def test_c_comment_only (self):
        """
        Parsing a file with only a C style comment must yield an empty list.
        """
        self.assert_data ("003_c_comment_only", [])

    def test_mixed_comment_only (self):
        """
        Parsing a file with only C and C++ style comments must yield an empty list.
        """
        self.assert_data ("004_mixed_comment_only", [])

    def test_single_empty_section (self):
        """
        An empty section must result in empty dict
        """
        self.assert_data ("005_single_empty_section", [("section1", {})])

    def test_single_simple_section (self):
        """
        An single section mapping a name to a scalar string value must result in
        a dict mapping that section name to dict. This dict must contain only that
        element name which is mapped to the correct string value.
        """
        self.assert_data ("006_single_simple_section", [('section2', {'foo': 'bar'})])

    def test_trailing_comma (self):
        """
        A section with multiple elements where the last element has a trailing
        comma (without a further element) must be parsed correctly.
        """
        self.assert_data("007_trailing_comma", [('section3', {'element1': 'data1', 'element2': 'data2'})])

    def test_multiple_simple_sections (self):
        """
        Two sections with simple data.
        """
        self.assert_data ("008_multiple_simple_sections",
            [('section5', {'element1': 'data1', 'element2': 'data2'}),
             ('section6', {'element3': 'data3', 'element4': 'data4'})])

    def test_section_with_lists (self):
        """
        A section containing lists of strings
        """
        self.assert_data ("009_section_with_lists",
            [('section8', {'element8':  ['data1', 'data2', 'data3'],
                           'element9':  ['data4', 'data5'],
                           'element10': ['data6']})])

    def test_single_variable (self):
        """
        File with one single variable assignment. Variables are stored in the 'variables' element
        of self._data
        """
        self.assert_variables ("010_single_variable", {'some_variable': 'data10'})

    def test_single_variable_list (self):
        """
        File with one single variable assignment of a string list.
        """
        self.assert_variables ("011_single_variable_list", {'variable_2': ['data1', 'data2']})

    def test_variable_use (self):
        """
        Use variable in a section. Eventually, the section must contain the variable value.
        """
        self.assert_data ("012_variable_use", [('section_10', {'data5': ['data3', 'data4']})])

    def test_missing_variable (self):
        """
        Use non-existing variable in a section. Must raise an exception.
        """
        with self.assertRaises (MissingVariable):
            self.parse ("013_missing_variable")

    def test_string_concatenation (self):
        """
        Concatenate string from two constants
        """
        self.assert_data ("014_string_const_cat", [('section_11', {'data6': 'leftright'})])

    def test_string_var_concatenation (self):
        """
        Concatenate string from a constant and a variable.
        """
        self.assert_data ("015_string_var_cat", [('section_12', {'data7': 'leftVARIABLE1', 'data8': 'VARIABLE2right'})])

    def test_var_stringlist_extension (self):
        """
        Assign a string list to a variable and extend it by another list.
        """
        self.assert_variables ("016_var_stringlist_ext", {'variable_12': ['data15', 'data16']})

    def test_var_string_extension (self):
        """
        Concatenate two strings
        """
        self.assert_variables ("017_var_string_ext", {'variable_19': 'data20data21'})

    def test_stringlist_cat (self):
        """
        Concatenate two string lists
        """
        self.assert_data ("018_stringlist_const_cat", [('section_21', {'data7': ['data30', 'data32', 'data33', 'data34', 'data35']})])

    def test_stringlist_var_cat1 (self):
        """
        Assign a string lists to a variable and concatenate it with a constant string list
        """
        self.assert_data ("019_stringlist_var_cat", [('section_21', {'data8': ['data30', 'data32', 'data33', 'data34', 'data35']})])

    def test_stringlist_var_cat2 (self):
        """
        Assign two concatenated string lists to a variable
        """
        self.assert_data ("020_stringlist_var_cat", [('section_22', {'data9': ['data50', 'data51', 'data52', 'data53', 'data54']})])

    def test_boolean_const (self):
        """
        Assign boolean constants
        """
        self.assert_data ("021_boolean_const", [('section_49', {'truevar': True, 'falsevar': False})])

    def test_boolean_var (self):
        """
        Assign boolean variable
        """
        self.assert_data ("022_boolean_var", [('section_123', {'boolean': True})])

    def test_boolean_cat_error (self):
        """
        Erroneously concatenate boolean variables
        """
        with self.assertRaises (Exception):
            self.parse ("023_boolean_cat_error")

    def test_stringlist_with_embedded_comma (self):
        """
        Parse string list where comma is embedded into an element
        """
        self.assert_variables ("024_stringlist_with_embedded_comma", {'variable': ['data12,data13']})

    def test_nested_section (self):
        """
        Nested sections
        """
        self.assert_data ("025_nested_sections", [('section_outer', {'section_inner': {'data_inner': 'data56'}, 'data_outer': 'data57'})])

    def test_multiple_files (self):
        """
        Parse multiple files that reference each other
        """
        soong = self.parse ("026_multi_file-1")
        soong.parse (self.fullpath ("026_multi_file-2"))
        self.assertEqual (soong.data(), [('section65', {'elem5': ['data54', 'data23', 'data87']})])

    def test_conflicting_vars (self):
        """
        Assign to the same variables twice. NB: I'm not entirely sure whether this is legal or not.
        For now, I assume this should not happen and must be detected as an error. We will see when
        validating against real-world data.
        """
        with self.assertRaises (DuplicateVariable):
            self.parse ("027_conflicting_vars")

    def test_conflicting_concatenation (self):
        """
        Concatenating variables of conflicting types (e.g. string list and string) should raise an exception.
        """
        with self.assertRaises (IncompatibleConcatenation):
            self.parse ("028_conflicting_concatenation")

    def test_multiple_files (self):
        """
        Parse multiple files with multiple sections
        """
        soong = self.parse ("029_multi_file_sections-1")
        soong.parse (self.fullpath ("029_multi_file_sections-2"))
        self.assertEqual (soong.data(), [('section_645', {'elem64': 'data545'}), ('section_223', {'elem845': ['data1246', 'data659']})])


if __name__ == "__main__":

    if len (sys.argv) == 2 and sys.argv[1] == 'test':
        suite = unittest.TestLoader().loadTestsFromTestCase(TestSoong)
        result = unittest.TextTestRunner().run(suite)

        if len(result.failures) > 0 or len(result.errors) > 0:
            sys.exit (1)

        for root, dirs, files in os.walk ('tests/desoongify'):
            for filename in files:
                full = root + "/" + filename
                print (full)
                soong = Soong (".")
                try:
                    soong.parse (full)
                except MissingVariable: pass

        sys.exit (0)

    parser = argparse.ArgumentParser (description = 'Translate soong files to make statements')
    parser.add_argument ('--verbose', help='Verbose output', action='store_true')
    parser.add_argument ('--basedir', help='Base directory', action='store', required=True)
    parser.add_argument ('--output',  help='Write result to file', action='store', required=True)
    parser.add_argument ('--prefix',  help='Prepend prefix to variables', action='store', default='')
    parser.add_argument ('--include', help='Directory to load Android.bp from', action='append', required=True)
    parser.add_argument ('queries',   help='Query data from soong file', nargs='+')
    args = parser.parse_args()

    soong = Soong (args.basedir)
    for bp in args.include:
        soong.parse (bp)

    sys.exit (0)
    with open (args.output, 'w') as f:
        for q in args.queries:
            query = SoongQuery (q)
            f.write (repr(soong[query]))

