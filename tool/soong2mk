#!/usr/bin/env python3

# TODO
#

import os
import sys
import argparse
import unittest

from pyparsing import *

class MissingVariable (Exception): pass
class DuplicateVariable (Exception): pass
class DuplicateEntry (Exception): pass
class IncompatibleConcatenation (Exception): pass
class NotFound (Exception): pass
class InvalidQuery (Exception): pass
class AmbiguousQuery (Exception): pass
class MergeIncompatibleSections (Exception): pass
class DefaultsNoList (Exception): pass
class NameNoString (Exception): pass

class Any: pass

class Wrap:

    def __init__ (self, data):
        self.__data = data

    def unwrap (self):
        return self.__data

#
# Soong query grammar
#
class SoongQuery:

    def attributeAction (self, string, location, tokens):
        return (tokens[0], tokens[1])

    def subqueryAction (self, string, location, tokens):
        attribute = tokens[1] if len(tokens) > 1 else None
        return (tokens[0], attribute)

    def wildcardAction (self, string, location, tokens):
        return Any

    def __init__ (self, querytext):

        name = Word (alphanums + "_")

        attribute = Suppress(Literal ('[') + Literal ('@')) + name + Suppress (Literal ('=')) + name + Suppress(Literal (']'))
        attribute.setParseAction (self.attributeAction)

        wildcard = Literal ('*')
        wildcard.setParseAction (self.wildcardAction)

        subquery = Suppress(Literal ('/')) + (wildcard|name) + Optional(attribute)
        subquery.setParseAction (self.subqueryAction)

        query = delimitedList (Group (OneOrMore(subquery)), delim='|') + StringEnd()
        self.__query = query.parseString (querytext)

    def query (self):
        return self.__query

#
# Soong parser
#
class Soong:

    def __init__ (self, basedir = '.'):
        self._data    = {'variables': {}, 'sections': []}
        self._basedir = basedir

        name  = Word (alphanums + "_")
        comma = Literal (',')
        true  = Literal ('true').setParseAction (lambda v : Wrap (True))
        false = Literal ('false').setParseAction (lambda v : Wrap (False))

        # Variable reference
        varref = Word (alphanums + "_")
        varref.setParseAction (self.varrefAction)

        # Boolean literal true/false
        boolean = true | false

        # String
        string = QuotedString ('"', escChar='\\').setParseAction (lambda s, l, t: t[0])

        # String concatenation
        stringcat = delimitedList (string|varref, delim='+')
        stringcat.setParseAction (self.stringcatAction)

        # List of strings
        stringlist = Suppress (Literal ("[")) + Optional (delimitedList (stringcat)) + Suppress (Optional (comma)) + Literal ("]")
        stringlist.setParseAction (self.stringlistAction)

        # Concatenation of strings, strings lists and variables
        element = delimitedList (string|stringlist|varref, delim='+')
        element.setParseAction (self.elementAction)

        # Data
        data = boolean | element
        data.setParseAction (lambda s, l, t: t)

        # Element inside a section
        section = Forward()
        dictelem = name + Suppress (Literal (':')|Literal ('=')) + (data|section)
        dictelem.setParseAction (self.dictelemAction)

        # Section (unnamed)
        section << Suppress (Literal ("{")) + Optional (delimitedList (dictelem)) + Suppress (Optional (comma) + Literal ("}"))
        section.setParseAction (self.sectionAction)

        # Named section
        namedsection = name + section
        namedsection.setParseAction (self.namedsectionAction)

        # Variable
        variable = name + Suppress (Literal ("=")) + (data|section)
        variable.setParseAction (self.variableAction)

        # Extension
        extension = name + Suppress (Literal ("+=")) + data
        extension.setParseAction (self.extensionAction)

        # Soong file
        self._grammar = ZeroOrMore (namedsection | Suppress (variable) | Suppress (extension)) + StringEnd()
        self._grammar.setParseAction (self.soongAction)

        # C and C++ style comments
        self._grammar.ignore (cppStyleComment | cStyleComment)

    def variableAction (self, string, location, tokens):
        varname = tokens[0]
        if varname in self.variables():
            raise DuplicateVariable
        data = tokens[1].unwrap()
        self.variables()[varname] = data

    def varrefAction (self, string, location, tokens):
        varname = tokens[0]
        if not varname in self.variables():
            raise MissingVariable ("Variable '" + varname + "' not found [line " + str(location) + "]")
        return [self.variables()[varname]]

    def extensionAction (self, string, location, tokens):
        varname   = tokens[0]
        variables = self.variables()
        value     = variables[varname]
        variables[varname] = value + tokens[1].unwrap()

    def stringlistAction (self, string, location, tokens):
        return [tokens[:-1]]

    def elementAction (self, string, location, tokens):
        result = tokens[0]
        for token in tokens[1:]:
            if type (token) != type (tokens[0]):
                raise IncompatibleConcatenation
            if type (token) is list:
                result.extend (token)
            else:
                result += token
        return Wrap (result)

    def stringcatAction (self, string, location, tokens):
        result = tokens[0]
        for token in tokens[1:]:
            result += token
        return result

    def dictelemAction (self, string, location, tokens):
        return (tokens[0], tokens[1].unwrap())

    def sectionAction (self, string, location, tokens):
        result = {}
        for token in tokens:
            if token[0] in result:
                raise DuplicateEntry (token[0])
            result[token[0]] = token[1]
        return Wrap (result)

    def namedsectionAction (self, string, location, tokens):
        return (tokens[0], tokens[1].unwrap())

    def soongAction (self, string, location, tokens):
        self._data['sections'].extend (tokens)

    def parse (self, infile):
        with open (infile, 'r') as f:
            self._grammar.parseFile (f)

    def data (self):
        return self._data['sections']

    def variables (self):
        return self._data['variables']

    def merge_section (self, left, right):

        if not left:
            return right

        result = left[1]

        for elem in right[1]:

            # Simple case: source element does not exist in target dict
            if not elem in result:
                result[elem] = right[1][elem]
            else:
                rt = type(result[elem])
                if rt != type(right[1][elem]):
                    raise MergeIncompatibleSections (str(elem) + ": " + str(rt))

                if rt == dict:
                    (__unused, result[elem]) = self.merge_section ((elem, result[elem]), (elem, right[1][elem]))
                elif rt == str or rt == bool:
                    result[elem] = right[1][elem]
                elif rt == list:
                    result[elem] += right[1][elem]
                else:
                    raise Exception ("Unhandled element type: %s", str(type(result[elem])))

        return ('%s+%s' % (left[0], right[0]), result)

    def query (self, querytext):

        result = None

        try:
            soong_query = SoongQuery (querytext)
        except ParseException:
            raise InvalidQuery

        for query in soong_query.query():

            subresult = None

            # Search first part of query
            (queryname, attr) = query[0]
            for section in self._data['sections']:
                (secname, secdata) = section
                if queryname == Any or queryname == secname:
                    if attr == None or attr[0] in secdata and secdata[attr[0]] == attr[1]:
                        if subresult != None:
                            raise AmbiguousQuery
                        subresult = section

            # Search subsequent parts of query
            for (queryname, attr) in query[1:]:
                if not subresult: raise NotFound
                found = False
                for secname in subresult[1]:
                    secdata = subresult[1][secname]
                    if queryname == Any or queryname == secname:
                        if attr == None or attr[0] in secdata and secdata[attr[0]] == attr[1]:
                            subresult = (queryname, secdata)
                            found = True
                if not found:
                    raise NotFound

            if not subresult:
                raise NotFound (querytext)

            result = self.merge_section (result, subresult)

        if 'name' in result[1] and not type (result[1]['name']) is str:
            raise NameNoString

        if 'defaults' in result[1]:

            if not type (result[1]['defaults']) is list:
                raise DefaultsNoList

            for default in result[1]['defaults']:
                defaults = self.query ('/*[@name=' + default + ']')
                result   = self.merge_section (defaults, result)

        return result

def mk (data, prefix = None):

    result = ""

    (secname, secdata) = data
    for elem in sorted(secdata):
        st = type(secdata[elem])
        if st  is str:
            result += '%s = "%s"\n' % (elem.upper(), secdata[elem])
        elif st is list:
            result += '%s =' % elem.upper()
            for elem in sorted (secdata[elem]):
                result += ' "%s"' % elem
            result += '\n'
        elif st is bool:
            result += '%s = %s\n' % (elem.upper(), str(secdata[elem]))
        elif st is dict:
            pass
        else:
            raise Exception ("Cannot convert element type '" + str(st) + "'")

    return result

#
# Soong parsers test cases
#
class TestSoong (unittest.TestCase):

    def setUp (self):
        self.testdir = "tests/soong2mk"

    def fullpath (self, testfile):
        return self.testdir + "/" + testfile + ".bp"

    def parse (self, filename):
        soong = Soong()
        soong.parse (self.fullpath (filename))
        return soong

    def assert_data (self, filename, data):
        soong = self.parse (filename)
        self.assertEqual (soong.data(), data, self.fullpath (filename))

    def assert_variables (self, filename, variables):
        soong = self.parse (filename)
        self.assertEqual (soong.variables(), variables, self.fullpath (filename))

    def query (self, filename, querytext):
        soong = self.parse (filename)
        return soong.query (querytext)

    def assert_query (self, filename, querytext, data):
        query = self.query (filename, querytext)
        self.assertEqual (query, data, self.fullpath (filename))

    def assert_mk (self, filename, querytext, data):
        query = self.query (filename, querytext)
        self.assertEqual (mk (query), data, self.fullpath (filename))

    def test_empty_input (self):
        """
        Parsing an empty file must yield an empty list.
        """
        self.assert_data ("001_empty_file", [])

    def test_cpp_comment_only (self):
        """
        Parsing a file with only a C++ style comment must yield an empty list.
        """
        self.assert_data ("002_cpp_comment_only", [])

    def test_c_comment_only (self):
        """
        Parsing a file with only a C style comment must yield an empty list.
        """
        self.assert_data ("003_c_comment_only", [])

    def test_mixed_comment_only (self):
        """
        Parsing a file with only C and C++ style comments must yield an empty list.
        """
        self.assert_data ("004_mixed_comment_only", [])

    def test_single_empty_section (self):
        """
        An empty section must result in empty dict
        """
        self.assert_data ("005_single_empty_section", [("section1", {})])

    def test_single_simple_section (self):
        """
        An single section mapping a name to a scalar string value must result in
        a dict mapping that section name to dict. This dict must contain only that
        element name which is mapped to the correct string value.
        """
        self.assert_data ("006_single_simple_section", [('section2', {'foo': 'bar'})])

    def test_trailing_comma (self):
        """
        A section with multiple elements where the last element has a trailing
        comma (without a further element) must be parsed correctly.
        """
        self.assert_data("007_trailing_comma", [('section3', {'element1': 'data1', 'element2': 'data2'})])

    def test_multiple_simple_sections (self):
        """
        Two sections with simple data.
        """
        self.assert_data ("008_multiple_simple_sections",
            [('section5', {'element1': 'data1', 'element2': 'data2'}),
             ('section6', {'element3': 'data3', 'element4': 'data4'})])

    def test_section_with_lists (self):
        """
        A section containing lists of strings
        """
        self.assert_data ("009_section_with_lists",
            [('section8', {'element8':  ['data1', 'data2', 'data3'],
                           'element9':  ['data4', 'data5'],
                           'element10': ['data6']})])

    def test_single_variable (self):
        """
        File with one single variable assignment. Variables are stored in the 'variables' element
        of self._data
        """
        self.assert_variables ("010_single_variable", {'some_variable': 'data10'})

    def test_single_variable_list (self):
        """
        File with one single variable assignment of a string list.
        """
        self.assert_variables ("011_single_variable_list", {'variable_2': ['data1', 'data2']})

    def test_variable_use (self):
        """
        Use variable in a section. Eventually, the section must contain the variable value.
        """
        self.assert_data ("012_variable_use", [('section_10', {'data5': ['data3', 'data4']})])

    def test_missing_variable (self):
        """
        Use non-existing variable in a section. Must raise an exception.
        """
        with self.assertRaises (MissingVariable):
            self.parse ("013_missing_variable")

    def test_string_concatenation (self):
        """
        Concatenate string from two constants
        """
        self.assert_data ("014_string_const_cat", [('section_11', {'data6': 'leftright'})])

    def test_string_var_concatenation (self):
        """
        Concatenate string from a constant and a variable.
        """
        self.assert_data ("015_string_var_cat", [('section_12', {'data7': 'leftVARIABLE1', 'data8': 'VARIABLE2right'})])

    def test_var_stringlist_extension (self):
        """
        Assign a string list to a variable and extend it by another list.
        """
        self.assert_variables ("016_var_stringlist_ext", {'variable_12': ['data15', 'data16']})

    def test_var_string_extension (self):
        """
        Concatenate two strings
        """
        self.assert_variables ("017_var_string_ext", {'variable_19': 'data20data21'})

    def test_stringlist_cat (self):
        """
        Concatenate two string lists
        """
        self.assert_data ("018_stringlist_const_cat", [('section_21', {'data7': ['data30', 'data32', 'data33', 'data34', 'data35']})])

    def test_stringlist_var_cat1 (self):
        """
        Assign a string lists to a variable and concatenate it with a constant string list
        """
        self.assert_data ("019_stringlist_var_cat", [('section_21', {'data8': ['data30', 'data32', 'data33', 'data34', 'data35']})])

    def test_stringlist_var_cat2 (self):
        """
        Assign two concatenated string lists to a variable
        """
        self.assert_data ("020_stringlist_var_cat", [('section_22', {'data9': ['data50', 'data51', 'data52', 'data53', 'data54']})])

    def test_boolean_const (self):
        """
        Assign boolean constants
        """
        self.assert_data ("021_boolean_const", [('section_49', {'truevar': True, 'falsevar': False})])

    def test_boolean_var (self):
        """
        Assign boolean variable
        """
        self.assert_data ("022_boolean_var", [('section_123', {'boolean': True})])

    def test_boolean_cat_error (self):
        """
        Erroneously concatenate boolean variables
        """
        with self.assertRaises (Exception):
            self.parse ("023_boolean_cat_error")

    def test_stringlist_with_embedded_comma (self):
        """
        Parse string list where comma is embedded into an element
        """
        self.assert_variables ("024_stringlist_with_embedded_comma", {'variable': ['data12,data13']})

    def test_nested_section (self):
        """
        Nested sections
        """
        self.assert_data ("025_nested_sections", [('section_outer', {'section_inner': {'data_inner': 'data56'}, 'data_outer': 'data57'})])

    def test_multiple_files (self):
        """
        Parse multiple files that reference each other
        """
        soong = self.parse ("026_multi_file-1")
        soong.parse (self.fullpath ("026_multi_file-2"))
        self.assertEqual (soong.data(), [('section65', {'elem5': ['data54', 'data23', 'data87']})])

    def test_conflicting_vars (self):
        """
        Assign to the same variables twice. NB: I'm not entirely sure whether this is legal or not.
        For now, I assume this should not happen and must be detected as an error. We will see when
        validating against real-world data.
        """
        with self.assertRaises (DuplicateVariable):
            self.parse ("027_conflicting_vars")

    def test_conflicting_concatenation (self):
        """
        Concatenating variables of conflicting types (e.g. string list and string) should raise an exception.
        """
        with self.assertRaises (IncompatibleConcatenation):
            self.parse ("028_conflicting_concatenation")

    def test_multiple_files (self):
        """
        Parse multiple files with multiple sections
        """
        soong = self.parse ("029_multi_file_sections-1")
        soong.parse (self.fullpath ("029_multi_file_sections-2"))
        self.assertEqual (soong.data(), [('section_645', {'elem64': 'data545'}), ('section_223', {'elem845': ['data1246', 'data659']})])

    def test_string_concatenation_in_stringlist (self):
        """
        Concatenate an element of a string list with a variable
        """
        self.assert_variables ("030_string_cat_in_stringlist", {'variable_a': 'data995', 'variable_b': ['data996', 'data997', 'data998data995']})

    def test_multi_variable_stringlist_concatenation (self):
        """
        Cocatenate multiple variables with a string list
        """
        self.assert_data ("031_multi_var_stringlist_cat", [('section', {'data': ["data1", "data2", "data3", "data4", "data5", "data6"]})])

    def test_section_variable (self):
        """
        Store section to variable
        """
        self.assert_data ("032_section_variable", [('section', {'subsection': {'elem_327': 'data345'}})])

    def test_query_root (self):
        """
        Query the root of the build file
        """
        with self.assertRaises (AmbiguousQuery):
            self.query ("033_query_test", "/section")

    def test_query_by_section (self):
        """
        Query by section name
        """
        self.assert_query ("033_query_test", "/section_2", ('section_2', {'name': 'third'}))

    def test_query_not_found (self):
        """
        Query a section that does not exist
        """
        with self.assertRaises (NotFound):
            self.query ("033_query_test", "/section_non_existent")

    def test_invalid_query (self):
        """
        An invalid query must raise an exception
        """
        with self.assertRaises (InvalidQuery):
            self.query ("033_query_test", "Invalid")

    def test_query_by_name (self):
        """
        Query a section by its name
        """
        self.assert_query ("033_query_test", '/section[@name=second]', ('section', {'name': 'second'}))

    def test_query_by_wildcard (self):
        """
        Ambiguous queries must result in an error
        """
        with self.assertRaises (AmbiguousQuery):
            self.query ("034_query_wildcard", '/*[@name=data2]')

    def test_query_subsection (self):
        """
        Query a sub-section by its name
        """
        self.assert_query ("035_query_subsection", '/section_outer/section_inner', ('section_inner', {'name': 'data2'}))

    def test_query_invalid_subsection (self):
        """
        Query a non-existent sub-section by its name
        """
        with self.assertRaises (NotFound):
            self.query ("035_query_subsection", '/section_outer/invalid')

    def test_query_subsubsection (self):
        """
        Query a sub-sub-section by its name
        """
        self.assert_query ("036_query_subsubsection", '/section_outer/section_inner/section_second_inner', ('section_second_inner', {'name': 'data3'}))

    def test_query_invalid_subsubsection (self):
        """
        Query a invalid sub-sub-section by its name
        """
        with self.assertRaises (NotFound):
            self.query ("037_query_invalid_subsubsection", '/section_outer/section_inner/invalid')

    def test_query_subsubsection_by_name (self):
        """
        Query a sub-sub-section by its name attribute
        """
        self.assert_query ("038_query_subsubsection_by_name", '/section_outer/*[@name=data2]/section_second_inner', ('section_second_inner', {'name': 'data3'}))

    def test_duplicate_section_entry (self):
        """
        A duplicate entry in a section must be detected
        """
        with self.assertRaises (DuplicateEntry):
            self.parse ("039_duplicate_section_entry")

    def test_multiple_sections (self):
        """
        Query two sections
        """
        self.assert_query ("040_query_multi_section", '/section_1|/section_2', ('section_1+section_2', {'elem1': 'data1', 'elem2': 'data2'}))

    def test_multiple_sections_string (self):
        """
        Query two sections with same string element
        """
        self.assert_query ("041_query_multi_section_strings", '/section_1|/section_2', ('section_1+section_2', {'elem1': 'data2'}))

    def test_multiple_sections_incompatible (self):
        """
        Query two sections with incompatible elements (string and string list)
        """
        with self.assertRaises (MergeIncompatibleSections):
            self.query ("042_query_multi_incompatible_sections", '/section_1|/section_2')

    def test_multiple_sections_lists (self):
        """
        Query two sections with same list element
        """
        self.assert_query ("043_query_multi_lists", '/section_1|/section_2', ('section_1+section_2', {'elem1': ['data1', 'data2', 'data3']}))

    def test_multiple_sections_lists (self):
        """
        Query two sections with same boolean element
        """
        self.assert_query ("044_query_multi_boolean", '/section_5|/section_7', ('section_5+section_7', {'elem53': False, 'elem54': True}))

    def test_multiple_sections_lists (self):
        """
        Query two sections, merge subsection if not present in target section
        """
        self.assert_query ("045_query_multi_subsection", '/section_1|/section_2', ('section_1+section_2', {'elem1': ['data1', 'data2', 'data4'], 'elem3': "data3", 'subsect1': {'elem2': True}, 'elem4': ['data5', 'data6']}))

    def test_multiple_sections_lists (self):
        """
        Query two sections, merge subsection
        """
        self.assert_query ("046_query_multi_subsect_merge", '/section_1|/section_2', ('section_1+section_2', {'elem1': ['data1', 'data2', 'data4'], 'elem3': "data3", 'subsect1': {'elem2': True, 'elem5': False}, 'elem4': ['data5', 'data6']}))

    def test_query_defaults (self):
        """
        Query a section with a default element
        """
        self.assert_query ("047_query_defaults", '/section_2', ('section_1+section_2', {'name': 'sec_name', 'defaults': ['sec_defaults'], 'elem1': ['data1', 'data2', 'data4'], 'elem3': "data3", 'subsect1': {'elem2': True}, 'elem4': ['data5', 'data6']}))

    def test_query_defaults_recursive (self):
        """
        Query a section with two cascaded default elements
        """
        self.assert_query ("048_query_defaults_recursive", '/section_3', ('section_1+section_2+section_3', {'name': 'third', 'defaults': ['defaults_1', 'defaults_2'], 'elem1': 'data1', 'elem2': 'data2', 'elem3': 'data3'}))

    def test_query_defaults_multiple (self):
        """
        Query a section with two default elements
        """
        self.assert_query ("049_query_defaults_multi", '/section_3', ('section_2+section_1+section_3', {'name': 'third', 'defaults': ['defaults_1', 'defaults_2'], 'elem1': 'data1', 'elem2': 'data2', 'elem3': 'data3'}))

    def test_check_defaults_is_list (self):
        """
        If defaults is not a list, raise an error
        """
        with self.assertRaises (DefaultsNoList):
            self.query ("050_check_defaults_is_list", '/section_1')

    def test_check_name_is_string (self):
        """
        If name is not a string, raise an error
        """
        with self.assertRaises (NameNoString):
            self.query ("051_check_name_is_string", '/section_1')

    def test_query_recursive_subsect_merge (self):
        """
        Query a section with a default element and subsections to be merged
        """
        self.assert_query ("052_query_recursive_subsect_merge", '/section_2', ('section_1+section_2', {'name': 'sec2', 'defaults': ['defaults_1'], 'subsect_2': {'subsubsect_3': {'elem1': 'data1', 'elem3': 'data4'}, 'elem2': ['data2', 'data3'], 'elem4': ['data5', 'data6']}, 'elem5': 'data7'}))

    def test_mk_simple (self):
        """
        Represent a section as make fragment
        """
        self.assert_mk ("052_query_recursive_subsect_merge", '/section_2', 'DEFAULTS = "defaults_1"\nELEM5 = "data7"\nNAME = "sec2"\n')

    def test_mk_list (self):
        """
        Check conversion of lists to make variable
        """
        self.assert_mk ("053_mk_list", '/section_1', 'ELEM1 = "data1" "data2" "data3"\nELEM2 = True\n')

if __name__ == "__main__":

    parser = argparse.ArgumentParser (description = 'Translate soong files to make statements')
    parser.add_argument ('--verbose', help='Verbose output', action='store_true')
    parser.add_argument ('--basedir', help='Base directory', action='store')
    parser.add_argument ('--output',  help='Write result to file', action='store')
    parser.add_argument ('--prefix',  help='Prepend prefix to variables', action='store', default='')
    parser.add_argument ('--include', help='Directory to load Android.bp from', action='append')
    parser.add_argument ('--test',    help='Run tests', action='store_true')
    parser.add_argument ('queries',   help='Query data from soong file', nargs='*')
    args = parser.parse_args()

    if args.test:
        suite = unittest.TestLoader().loadTestsFromTestCase(TestSoong)
        result = unittest.TextTestRunner().run(suite)

        if len(result.failures) > 0 or len(result.errors) > 0:
            sys.exit (1)

        print ("Testing Android build files ", end='')
        no_files=0
        for root, dirs, files in os.walk ('tests/android'):
            for filename in sorted (files):
                print ('.', end='', flush=True)
                no_files += 1
                full = root + "/" + filename
                soong = Soong ()
                try:
                    soong.parse (full)
                except MissingVariable: pass
                except Exception:
                    print ("\n" + full)
                    raise

        print ("\n%d files tests" % (no_files))
        sys.exit (0)

    if not args.basedir:
        print ("No --basedir directory set")
        parser.print_help()
        sys.exit (1)

    if not args.output:
        print ("No --output directory set")
        parser.print_help()
        sys.exit (1)

    if not args.include:
        print ("No --include directory set")
        parser.print_help()
        sys.exit (1)

    if len (args.queries) == 0:
        print ("No query")
        parser.print_help()
        sys.exit (1)

    soong = Soong (args.basedir)
    for bp in args.include:
        soong.parse (bp)

    soong = Soong (args.basedir)
    for name in args.include:
        soong.parse (name)

    try:
        querytext = "|".join (args.queries)
        query = soong.query (querytext)
        mk (query)
    except NotFound:
        print ("Query " + querytext + " did not match any section in " + str(args.include))
        sys.exit (1)
    except AmbiguousQuery:
        print ("Query " + querytext + " resulted in multiple sections in " + str(args.include))
        sys.exit (1)
