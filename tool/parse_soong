#!/usr/bin/env python3

import sys
import pprint
import argparse
from pyparsing import *
from pathlib import Path

colon  = Literal (':')
name   = Word (alphanums + "_")
equals = Literal ('=')

def make_error (message):
    print ("$(error " + sys.argv[0] + ": " + message + ")\n")

class Bool:

    def __init__ (self, value = None):
        self._value = value

    def __add__ (self, item):
        return (Bool (item.value()))

    def value (self):
        return self._value

class Attr:

    def __init__ (self, name, value):
        self._name  = name
        self._value = value

    def __repr__ (self):
        return "[@" + self._name + "=" + self._value + "]"

    def name (self):
        return self._name

    def value (self):
        return self._value

class NullAttr:

    def __repr__ (self):
        return ""

class Subquery:

    def __init__ (self, name, attr = NullAttr()):
        self._name = name
        self._attr = attr

    def __repr__ (self):
        return "/" + self._name + repr(self._attr)

    def name (self):
        return self._name

    def attr (self):
        if isinstance (self._attr, NullAttr):
            return None
        return self._attr

class QueryError (Exception): pass
class InputError (Exception): pass
class NotImplemented (Exception): pass

class SoongQuery:

    def attributeAction (self, string, location, tokens):
        return Attr (tokens[0], tokens[1])

    def subqueryAction (self, string, location, tokens):
        attribute = tokens[1] if len(tokens) > 1 else NullAttr()
        return Subquery (tokens[0], attribute)

    def __init__ (self, query_text, prefix = ""):

        self.prefix = prefix
        self.query_text = query_text

        slash    = Literal ('/')
        lbrak    = Literal ('[')
        rbrak    = Literal (']')
        at       = Literal ('@')
        asterisk = Literal ('*')

        attribute = Suppress(lbrak + at) + name + Suppress(equals) + name + Suppress(rbrak)
        attribute.setParseAction (self.attributeAction)

        subquery = Suppress(slash) + (name|asterisk) + Optional(attribute)
        subquery.setParseAction (self.subqueryAction)

        query = OneOrMore(subquery) + StringEnd()
        self.query = query.parseString (query_text)

    def __getitem__ (self, pos):
        return self.query[pos]

    def __repr__ (self):
        return self.query_text

class Elem:

    def __init__ (self, data = {}):
        self._data = data

    def __iter__ (self):
        return self._data.__iter__()

    def __getitem__ (self, item):
        return self._data[item]

    def __contains__ (self, item):
        return item in self._data

    def __repr__ (self):
        return repr(self._data)

    def data (self):
        return self._data

class StringlistElem (Elem):

    def __add__ (self, item):
        return StringlistElem (self._data + item._data)

    def extend (self, item):
        self._data.extend (item._data)
        return StringlistElem (self._data)

class SecElem (Elem):

    def __add__ (self, item):

        for elem in item._data:

            if elem == 'name': continue
            if elem == 'defaults': continue

            # Just copy entries not present in result dict
            if not elem in self._data:
                self._data[elem] = item._data[elem]
                continue

            if type(self._data[elem]) != type(item._data[elem]):
                raise InputError ("Incompatible type in section '" + elem + \
                    "': ltype=" + str(type(self._data[elem])) + \
                    " rtype="+ str(type(item._data[elem])))

            self._data[elem] += item._data[elem]

        return SecElem (self._data)

    def __repr__ (self):

        result  = ""
        section = self.data()

        for name in section:

            elem = section[name]

            # Store section name and continue
            if name == "name": continue

            # Skip sub-entries
            if not isinstance (elem, StringlistElem): continue

            result += name.upper() + " += " + " ".join (elem) + "\n"

        return result

class NamedElem:

    def __init__ (self, name, data = SecElem()):
        self._name = name
        self._data = data

    def __getitem__ (self, sq):
        data = self.data()
        if sq.name() == '*' or sq.name() == self.name():
            if sq.attr() == None:
                return data
            attr_name = sq.attr().name()
            attr_val  = sq.attr().value()
            if attr_name in data and attr_val == data[attr_name]:
                return data
        return None

    def __contains__ (self, subquery):
        result = self[subquery]
        return result != None

    def __add__ (self, item):
        return NamedElem (self.name(), self.data() + item.data())

    def __repr__ (self):
        return repr (self.data())

    def name (self):
        return self._name

    def data (self):
        return self._data

class BlockElem (NamedElem): pass

class SoongParser:

    def stringJoinAction (self, string, location, tokens):
        return "".join (tokens)

    def stringListAction (self, string, location, tokens):
        last = -2 if tokens[-2] == ',' else -1
        return StringlistElem (tokens[1:last])

    def stringListJoinAction (self, string, location, tokens):
        result = tokens[0]
        if len(tokens) == 2:
            result.extend (tokens[1])
        return StringlistElem (result)

    def dictelemAction (self, string, location, tokens):
        return NamedElem (tokens[0], tokens[2])

    def elementAction (self, string, location, tokens):
        return tokens

    def blockAction (self, string, location, tokens):
        return BlockElem (tokens[0], tokens[1])

    def variableAction (self, string, location, tokens):
        self.variables[tokens[0]] = tokens[2]

    def extensionAction (self, string, location, tokens):
        raise NotImplemented ("WARNING: Extension not supported: " + str(tokens))

    def rnameAction (self, string, location, tokens):
        varname = tokens[0]
        if not varname in self.variables:
            raise Exception ("Error: %s: Variable '%s' no found" % (str(self.bp), varname))
        return self.variables[varname]

    def sectionAction (self, string, location, tokens):
        result = {}
        last = -2 if tokens[-2] == ',' else -1
        for token in tokens[1:last]:
            result[token.name()] = token.data()
        return SecElem (result)

    def soongAction (self, string, location, tokens):
        self._data.extend (tokens)

    def __init__ (self, basedir):

        self.variables = {}
        self._data = []

        self.basedir = basedir

        comma   = Literal (',')
        true    = Literal ('true').setParseAction (lambda v : Bool(True))
        false   = Literal ('false').setParseAction (lambda v : Bool(False))

        # Variable reference
        rname = Word (alphanums + "_")
        rname.setParseAction (self.rnameAction)

        # Boolean literal true/false
        boolean     = true | false

        # String
        string     = QuotedString ('"', escChar='\\').setParseAction (lambda s, l, t: t[0])

        stringjoin = delimitedList (string, delim='+')
        stringjoin.setParseAction (self.stringJoinAction)

        # List of strings
        stringlist     = Literal ("[") + Optional (delimitedList (stringjoin)) + Optional (comma) + Literal ("]")
        stringlist.setParseAction (self.stringListAction)

        stringlistjoin = delimitedList (stringlist|rname, delim='+')
        stringlistjoin.setParseAction (self.stringListJoinAction)

        # Dictionary
        dictelem    = Forward()
        dictelem.setParseAction (self.dictelemAction)

        section = Literal ("{") + Optional (delimitedList (dictelem)) + Optional (comma) + Literal ("}")
        section.setParseAction (self.sectionAction)

        block = name + section
        block.setParseAction (self.blockAction)

        # Element
        element   = boolean | stringlistjoin | stringlist | stringjoin | string | rname | section
        element.setParseAction (self.elementAction)

        dictelem << name + (colon|equals) + element

        variable = name + Literal ("=") + element
        variable.setParseAction (self.variableAction)

        extension = name + Literal ("+=") + element
        extension.setParseAction (self.extensionAction)

        self.grammar = ZeroOrMore (block | Suppress (variable) | Suppress (extension)) + StringEnd()
        self.grammar.setParseAction (self.soongAction)

        # C and C++ style comments
        self.grammar.ignore (cppStyleComment | cStyleComment)

    def parse (self, subdirs):
        for subdir in subdirs:
            self.bp = Path (self.basedir + "/" + subdir + "/Android.bp")
            if not self.bp.is_file():
                raise Exception ("File " + str(self.bp) + " does not exist")
            self.grammar.parseFile (self.bp.open())

    def __getitem__ (self, subquery):

        sections = [sec for sec in self._data if subquery[0] in sec] 
        if len(sections) != 1:
            raise QueryError ("Ambigous query: " + str(subquery))

        section = sections[0]
        data    = section.data()

        depsec = BlockElem (section.name())
        if 'defaults' in data:
            for default in data['defaults']:
                depquery = SoongQuery ("/*[@name=" + default + "]")
                s = self[depquery]
                depsec += s

        result = depsec + section

        for query in subquery[1:]:
            if not query.name() in result.data():
                raise QueryError ("NOT FOUND: " + str(query))
            result = result.data()[query.name()]

        return result

def test():
    import os

    count = 0
    failed = {}

    soong = SoongParser (".")
    for root, dirs, files in os.walk ("tests/"):
        if 'Android.bp' in files:
            try:
                count += 1
                soong.parse ([root])
                print (".", end='', flush=True)
            except Exception as e:
                failed[root] = e
                print ("!", end='', flush=True)

    print ("\nRan %d tests, %d failed (%2.1f%%):" % (count, len(failed), 100*len(failed)/count))
    for bp in failed:
        print ("%s:" % bp)
        print ("   %s" % failed[bp])

if __name__ == "__main__":

    if len (sys.argv) == 2 and sys.argv[1] == 'test':
        sys.exit (test())

    parser = argparse.ArgumentParser (description = 'Translate soong file to make statements')
    parser.add_argument ('--verbose', help='Verbose output', action='store_true')
    parser.add_argument ('--basedir', help='Base directory', action='store', required=True)
    parser.add_argument ('--prefix',  help='Prepend prefix to variables', action='store', default='')
    parser.add_argument ('--include', help='Directory to load Android.bp from', action='append', required=True)
    parser.add_argument ('query',     help='Query data from soong file')
    args = parser.parse_args()

    try:
        soong = SoongParser (args.basedir)
        soong.parse (args.include)

        query = SoongQuery (args.query, args.prefix)
        result = soong[query]
        print (result)

    except Exception as e:
        make_error (e.__class__.__name__ + ": " + str(e))
        if args.verbose: raise
