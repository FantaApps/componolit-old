#!/usr/bin/env python3
#
# (C) 2017 Alexander Senier <senier@componolit.com>
#
# Foobar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Foobar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
#
# This tool is based on the following public domain code:
# elftools example: dwarf_decode_address.py
# Eli Bendersky (eliben@gmail.com)
#

import re
import sys
import fileinput
from pathlib import Path

# pip3 install pyelftools
from elftools.common.py3compat import maxint, bytes2str
from elftools.dwarf.descriptions import describe_form_class
from elftools.elf.elffile import ELFFile

def decode_funcname(dwarfinfo, address):
    # Go over all DIEs in the DWARF information, looking for a subprogram
    # entry with an address range that includes the given address. Note that
    # this simplifies things by disregarding subprograms that may have
    # split address ranges.
    for CU in dwarfinfo.iter_CUs():
        for DIE in CU.iter_DIEs():
            try:
                if DIE.tag == 'DW_TAG_subprogram':
                    lowpc = DIE.attributes['DW_AT_low_pc'].value

                    # DWARF v4 in section 2.17 describes how to interpret the
                    # DW_AT_high_pc attribute based on the class of its form.
                    # For class 'address' it's taken as an absolute address
                    # (similarly to DW_AT_low_pc); for class 'constant', it's
                    # an offset from DW_AT_low_pc.
                    highpc_attr = DIE.attributes['DW_AT_high_pc']
                    highpc_attr_class = describe_form_class(highpc_attr.form)
                    if highpc_attr_class == 'address':
                        highpc = highpc_attr.value
                    elif highpc_attr_class == 'constant':
                        highpc = lowpc + highpc_attr.value
                    else:
                        print('Error: invalid DW_AT_high_pc class:',
                              highpc_attr_class)
                        continue

                    if lowpc <= address <= highpc:
                        return DIE.attributes['DW_AT_name'].value
            except KeyError:
                continue
    return None


def decode_file_line(dwarfinfo, address):
    # Go over all the line programs in the DWARF information, looking for
    # one that describes the given address.
    for CU in dwarfinfo.iter_CUs():
        # First, look at line programs to find the file/line for the address
        lineprog = dwarfinfo.line_program_for_CU(CU)
        prevstate = None
        for entry in lineprog.get_entries():
            # We're interested in those entries where a new state is assigned
            if entry.state is None or entry.state.end_sequence:
                continue
            # Looking for a range of addresses in two consecutive states that
            # contain the required address.
            if prevstate and prevstate.address <= address < entry.state.address:
                filename = lineprog['file_entry'][prevstate.file - 1].name
                line = prevstate.line
                return filename, line
            prevstate = entry.state
    return None, None

class MemoryMap:

    def __init__ (self):
        self.__ranges = {}
        self.__dwarf = {}
        self.__path = Path('debug')

    def load_dwarfinfo (self, filename):

        elffile = self.__path / Path(filename)

        if not elffile.exists() or not elffile.is_file():
            return None

        with elffile.open('rb') as f:
            elffile = ELFFile(f)
            if elffile.has_dwarf_info():
                return elffile.get_dwarf_info()

        return None

    def add (self, app, start, end, lib):

        if not app in self.__ranges:
            self.__ranges[app] = {}
            m = re.match('.*?([^\s]+)$', app)
            if not m:
                print("%s: Error extracting binary name." % (sys.argv[0]))
                return
            binname = m.group(1)
            self.__dwarf['__THIS_APP__'] = self.load_dwarfinfo(binname)

        self.__ranges[app][lib] = (start, end)

        #print("RESOLVE: %s: %x-%x - %s" % (app, start, end, lib))
        self.__dwarf[lib] = self.load_dwarfinfo(lib)

    def resolve (self, app, addr):

        for lib in self.__ranges[app]:
            (start, end) = self.__ranges[app][lib]
            if addr >= start and addr <= end:
                (filename, funcname, line) = self.process_lib(lib, addr - start - 4)
                funcname = "???" if funcname == None else funcname
                return "%x %s() (%s:%d)" % (addr, funcname, filename, line)

        (filename, funcname, line) = self.process_lib('__THIS_APP__', addr - 4)
        return "%x %s() (%s:%d)" % (addr, funcname, filename, line)

    def match (self, line):

        match = re.match('^\[([^\]]+)\]\s+(0x[0-9a-f]+) \.\. (0x[0-9a-f]+):\s+(.*)$', line)
        if match:
            app = match.group(1)
            addr_start = int(match.group(2), 16)
            addr_end   = int(match.group(3), 16)
            lib = match.group(4)
    
            self.add(app, addr_start, addr_end, lib)
            return
    
        match = re.match('^\[([^\]]+)\]\s+(0x[0-9a-f]+)', line)
        if  match:
            app = match.group(1)
            addr = int(match.group(2), 16)
    
            resolved = self.resolve(app, addr)
            print("[%s] %s" % (app, resolved))
            return

        print (line, end='')

    def process_lib(self, lib, address):

        dwarfinfo = self.__dwarf[lib]
        if not dwarfinfo:
            return ('???', '???', 0)

        funcname = decode_funcname(dwarfinfo, address)
        filename, line = decode_file_line(dwarfinfo, address)

        funcname = funcname.decode('utf-8') if funcname != None else "???"
        filename = filename.decode('utf-8') if filename != None else "???"

        return (filename, funcname, line)

def main():

    mapping = MemoryMap()
    
    for line in fileinput.input():
        mapping.match(line)


if __name__ == "__main__":
    main()
